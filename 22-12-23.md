# 22-12-23 

# 计网 基础知识

## 1、为什么需要三次握手？两次不行？

1. 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 **ISN(c)**。此时客户端处于 **SYN_Send** 状态。
1. 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 **SYN_RCVD** 的状态。
1. 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 **established** 状态。
1. 服务器收到 ACK 报文之后，也处于 **established 状态**，此时，双方以建立起了链接

### 三次握手的作用

1. 确认双方的接受能力、发送能力是否正常。

2. 指定自己的初始化序列号，为后面的可靠传送做准备。

### 拓展：

#### 1、（ISN）是固定的吗

+ 三次握手的一个重要功能是客户端和服务器交换ISN（Initial Sequence Number）,以便让对方知道接下来接收数据的时候如何按序列号组装数据。
+ 如果ISN是固定的，攻击者很容易猜出后续的确认号，因此ISN是动态生成的。

#### 2、什么是半连接队列

+ 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为**半连接队列**。当然还有一个**全连接队列**，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

  > 这里在补充一点关于**SYN-ACK 重传次数**的问题：　服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s,

#### 3、三次握手过程中可以携带数据吗

+ 很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。
+ 假如第一次握手可以携带数据，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，攻击者根本就不需要管服务器的接收、发送能力是否正常，疯狂着重复发 SYN 报文，这就会让服务器花费很多时间、内存空间来接收这些报文。所以第一次握手可以放数据的话，会让服务器更加容易受到攻击了。
+ 而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。

## 2、为什么需要四次挥手？三次不行？

+ 刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：

  1. 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于**FIN_WAIT1**状态。

  2. 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 **CLOSE_WAIT**状态。

  3. 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 **LAST_ACK** 的状态。
  4. 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 **TIME_WAIT** 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态
  5. 服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

>这里特别需要主要的就是**TIME_WAIT**这个状态了,为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。

> 至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。

### 拓展：

1. LISTEN – 侦听来自远方TCP端口的连接请求；
2. SYN-SENT -在发送连接请求后等待匹配的连接请求；
3. SYN-RECEIVED – 在收到和发送一个连接请求后等待对连接请求的确认；
4. ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；
5. FIN-WAIT-1 – 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；
6. FIN-WAIT-2 – 从远程TCP等待连接中断请求；
7. CLOSE-WAIT – 等待从本地用户发来的连接中断请求；
8. CLOSING -等待远程TCP对连接中断的确认；
9. LAST-ACK – 等待原来发向远程TCP的连接中断请求的确认；
10. TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；
11. CLOSED – 没有任何连接状态；

## 3、HTTP1.0、1.1、2.0的版本区别

### HTTP/1.0

+ 1996年5月，HTTP/1.0 版本发布，为了提高系统的效率，**HTTP/1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接**，服务器不跟踪每个客户也不记录过去的请求。

+ 这种方式就好像我们打电话的时候，只能说一件事儿一样，说完之后就要挂断，想要说另外一件事儿的时候就要重新拨打电话。

+ HTTP/1.0中浏览器与服务器只保持短暂的连接，连接无法复用。也就是说每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。

  >HTTP1.0 其实也可以强制开启长链接，例如接受`Connection: keep-alive` 这个字段，但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。

### HTTP/1.1

+ HTTP/1.1于1999年诞生。相比较于HTTP/1.0来说，最主要的改进就是引入了持久连接。所谓的持久连接即**TCP连接默认不关闭，可以被多个请求复用**。
+ 由于之前打一次电话只能说一件事儿，效率很低。后来人们提出一种想法，就是电话打完之后，先不直接挂断，而是持续一小段时间，这一小段时间内，如果还有事情沟通可以再次进行沟通。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。或者客户端在最后一个请求时，主动告诉服务端要关闭连接。
+ HTTP/1.1版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。
+ **有了持久连接和管道，大大的提升了HTTP的效率。但是服务端还是顺序执行的，效率还有提升的空间。**

### HTTP/2

+ 2015年，HTTP/2 发布,主要基于 SPDY 协议
+ HTTP/2 采用了**多路复用**。即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。
+ 能这样做有一个前提，就是HTTP/2进行了**二进制分帧**，即 HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码。
  + 老板可以同时下达多个命令，员工也可以收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。A请求的两部分响应在组合到一起发给老板。
  + 而这个负责拆分、组装请求和二进制帧的一层就叫做**二进制分帧层**。
+ 除此之外，还有一些其他的优化，比如做Header压缩、服务端推送等。
+ **Header压缩**就是压缩老板和员工之间的对话。
+ **服务端推送**就是员工事先把一些老板可能询问的事情提现发送到老板的手机（缓存）上。这样老板想要知道的时候就可以直接读取短信（缓存）了。



## 4、TCP 如何保证有效传输及拥塞控制原理

+ TCP 的拥塞控制主要是==根据网络中的拥塞情况来控制发送方数据的发送速率==，如果网络处于拥塞的状态，发送方就减小发送的速率，这样一方面是为了避免继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。
+ TCP 的拥塞控制主要使用了四个机制，分别是慢启动、拥塞避免、快速重传和快速恢复。
  + **慢启动**的基本思想是，因为在发送方刚开始发送数据的时候，并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探 ，每次收到一个确认报文，就将发动窗口的长度加一，这样每个 RTT 时间后，发送窗口的长度就会加倍。当发送窗口的大小达 到一个阈值的时候就进入拥塞避免算法。
  + **拥塞避免**算法是为了避免可能发生的拥塞，将发送窗口的大小由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。 这样将窗口的增长速率由指数增长，变为加法线性增长。
  + **快速重传**指的是，当发送方收到三个冗余的确认应答时，因为 TCP 使用的是累计确认的机制，所以很有可能是发生了报文段的 丢失，因此采用立即重传的机制，在定时器结束前发送所有已发送但还未接收到确认应答的报文段。
  + **快速恢复**是对快速重传的后续处理，因为网络中可能已经出现了拥塞情况，所以会将慢启动的阀值减小为原来的一半，然后将拥 塞窗口的值置为减半后的阀值，然后开始执行拥塞避免算法，使得拥塞窗口缓慢地加性增大。简单来理解就是，乘性减，加性增。
+ TCP 认为网络拥塞的主要依据是报文段的重传次数，它会根据网络中的拥塞程度，通过调整慢启动的阀值，然后交替使用上面四 种机制来达到拥塞控制的目的。



# JAVA 基础知识

## 1、解释一下什么是面向对象？面向对象和面向过程的区别？

+ （Object Oriented Programming）面向对象是一种基于面向过程（Object Oriented Design）的编程思想，是向现实世界模型的自然延伸，这是一种“万物皆对象”的编程思想。由执行者变为指挥者，在现实生活中的任何物体都可以归为一类事物，而每一个个体都是一类事物的实例。面向对象的编程是以对象为中心，以消息为驱动。

+ 区别:

  （1）编程思路不同：面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。

  （2）封装性：都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。

  （3）面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势很明显

## 2、面向对象的三大特性？分别解释下？

+ 封装：通常认为封装是把数据和操作数据的方法封装起来，对数据的访问只能通过已定义的接口。

+ 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类/基类），得到继承信息的被称为子类（派生类）。
+ 多态：分为编译时多态（方法重载）和运行时多态（方法重写）。要实现多态需要做两件事：一是子类继承父类并重写父类中的方法，二是用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为。

## 3、==和equals的区别？

+ = =：如果比较的对象是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象的地址值是否相等。
+ equals 方法：用来比较两个对象的内容是否相等。注意：equals 方法不能用于比较基本数据类型的变量。如果没有对 equals 方法进行重写，则比较的是引用类型的变量所指向的对象的地址（很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等）。

## 4、List<? extends T> 和 List<? Super T> 之间有什么区别？

+ **上限<? extends T>不能往里存，只能往外取 (即：只能get)**

  因为编译器只知道容器里的是Fruit或者Fruit的子类，但不知道它具体是什么类型，所以存的时候，无法判断是否要存入的数据的类型与容器种的类型一致，所以会拒绝set操作。

+ **下限<? super T>往外取只能赋值给Object变量，不影响往里存**

  因为编译器只知道它是Fruit或者它的父类，这样实际上是放松了类型限制，Fruit的父类一直到Object类型的对象都可以往里存，但是取的时候，就只能当成Object对象使用了。

> 所以如果需要经常往外读，则使用<? extends T>，如果需要经常往外取，则使用<? super T>。

## 5、String字符串修改实现的原理？

+ 当用 String 类型来对字符串进行修改时，其实现方法是首先创建一个 StringBuilder，其次调用 StringBuilder 的 append() 方法，最后调用 StringBuilder 的 toString() 方法把结果返回。

## 6、BIO、NIO、AIO有什么区别？



# MySQL 基础知识

## 一条SQL语句在数据库框架中的执行流程？

1. 应用程序把查询 SQL 语句发送给服务器端执行；

2. 查询缓存，如果查询缓存是打开的，服务器在接收到查询请求后，并不会直接去数据库查询，而是在数据库的查询缓存中找是否有相对应的查询数据，如果存在，则直接返回给客户端。只有缓存不存在时，才会进行下面的操作；

3. 查询优化处理，生成执行计划。这个阶段主要包括解析 SQL、预处理、优化 SQL 执行计划；

4. MySQL 根据相应的执行计划完成整个查询；

