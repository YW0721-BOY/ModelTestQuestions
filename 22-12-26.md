# 22-12-26

## 1. 哈希索引时间复杂度，为什么会失去有序性



## 2.索引优化的方法有哪几种？



## 3.讲讲分布式锁

(Redis内容)

## 4.我们能将 int强制转换为byte 类型的变量么？如果该值大于byte类型的范围，将会出现什么现象？

是的，我们可以做强制转换，但是Java中int是32位的，而byte是8位的，所以，如果强制转化,int类型的高24位将会被丢弃，byte类型的范围是从-128到127

## 5.哪个类包含clone方法？是Cloneable还是Object?

java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。

> 在java 中，RandomAccess和Cloneable 、Serializable一样，都是标志性接口，不需要任何实现，只是又来表明其实现类具体有某种特质的，实现了Cloneable表明可以拷贝，实现Serializable 接口表明被序列化了，实现RandomAccess接口则表明这个类可以随机存取。

## 6. 3*0.1== 0.3将会返回什么？true还是false？

false，因为有些浮点数不能完全精确的表示出来，使用BigDecimal能够精确的运算浮点型数据。

> 为什么不能完全精确的表示出来

## 7.int 和 Integer 哪个会占用更多的内存？

Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。

但是 int 是一个原始类型的数据，所以占用的空间更少。

> int是基本数据类型，int变量存储的是数值。Integer是引用类型，实际是一个对象，Integer存储的是引用对象的地址。Integer变量（无论是否是new生成的）与int变量比较，只要两个变量的值是相等的，结果都为true。非new生成的Integer变量与new Integer生成的变量比较，结果为false。

## 8.对equals()和hashCode()的理解？

[对equals()和hashCode()的理解]: https://www.cnblogs.com/moershiwei/p/12643626.html

>equals()相同，hashCode()肯定相同；
>
>equals()不同，hashCode()不一定不相同；（此情况就是哈希冲突）；

**hashCode()的返回值和equals()的关系如下：**

   如果x.equals(y)返回“true”，那么x和y的hashCode()必须相等。 

   如果x.equals(y)返回“false”，那么x和y的hashCode()有可能相等，也有可能不等。

**重写hashCode时注意事项**

（1）返回的hash值是int型的，防止溢出。

（2）不同的对象返回的hash值应该尽量不同。（为了hashMap等集合的效率问题）

（3）《Java编程思想》中提到一种情况

“设计hashCode()时最重要的因素就是：无论何时，对同一个对象调用hashCode()都应该产生同样的值。如果在讲一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。所以如果你的hashCode方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的散列码”。



## 9.a=a+b与a+=b的区别

> **一、运算过程中，低精度的类型向高精度类型转换。二、如果将高精度的数值赋值给低精度类型变量，则必须要进行显性的强制转换。**

1. 性能方面
   　　a=a+b是加法运算 需要两次寻找地址而a+=b是增量运算有寄存器优先时只有一次地址查找。效率方面后者略高于前者 基于现在计算机的发展可忽略不计。
2. 可读性方面
   　　两者都是赋值运算，一般情况下可以认为两者没有什么区别 但前者与数学算法描述更接近相对来说更严谨而后者书写更快捷但可读性下降。
3. 数据类型方面
   　　两者写法上主要在于是否能进行数据类型自动转换，事实上就是类型与精度上的差异。**eg:当两个操作数 数据类型一致时两种形式的运算结果没有差别 但数据类型不同时 且a值的数据类型精度低时 此时两种形式就有区别了。**



