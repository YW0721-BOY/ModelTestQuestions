# 22-12-28

## 1.B+Tree与B-Tree的区别

[索引](https://github.com/YW0721-BOY/JavaWeb_Learning/blob/master/mysql/索引.md)

[B-Tree 与 B+Tree的区别](https://blog.csdn.net/XZQ_STUD/article/details/112907790?)

1. 所有的数据都会出现在叶子节点
2. 叶子节点形成一个单向链表

## 2.hash冲突是什么？解决方法有哪些？优缺点

### 一、哈希表

**概念：**

哈希表（又叫[散列表](https://so.csdn.net/so/search?q=散列表&spm=1001.2101.3001.7020)）是根据关键码值(Key value)而直接进行访问的[数据结构](https://baike.baidu.com/item/数据结构/1450)。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做[散列函数](https://baike.baidu.com/item/散列函数/2366288)，存放记录的[数组](https://baike.baidu.com/item/数组/3794097)叫做[散列表](https://baike.baidu.com/item/散列表/10027933)。

### 二、哈希冲突

我认为哈希表其实就是一个存放哈希值的一个数组，哈希值是通过哈希函数计算出来的，那么哈希冲突就是两个不同值的东西，通过哈希函数计算出来的哈希值相同，这样他们存在数组中的时候就会发生冲突，这就是哈希冲突。就像是高铁座位，一般是一人一座的，但是突然系统可能出了问题，两个人可能买到了同一个座位的票，那么这时候就发生了冲突。

### 三、怎样解决哈希冲突

一般解决哈希冲突有以下四个方法：

**1.开放地址法**

这种方法也称**再散列法**，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。

就是说当发生冲突时，就去寻找下一个空的地址把数据存入其中，只要哈希表足够大，就总能找到这样一个空的地址。

**2.拉链法**

将所有关键字为同义字的记录存储在一个单链表中 

**3.再哈希法**

在发生冲突的时候再用另外一个哈希函数算出哈希值，直到算出的哈希值不同为止。

**4.建立公共溢出区**

在创建哈希表的同时，再额外创建一个公共溢出区，专门用来存放发生哈希冲突的元素。查找时，先从哈希表查，查不到再去公共溢出区查。



## 3.为什么InnoDB存储引擎选择使用B+Tree索引结构

- 相较于二叉树，层级更少，搜索效率高；
- 对于B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页存储的键值减少，指针跟着减少，要保存大量数据，只能增加树的高度，导致性能降低
- 相对Hash索引，B+Tree支持范围匹配及排序操作

## 4. 方法引用时要注意什么？

1. 需要有函数式接口
2. 被引用的方法必须已经存在
3. 被引用方法的形参，需要跟抽象方法的第二个形参到最后一个形参保持一致，返回值需要保持一致
4. 被引用方法的功能需要满足当前的需求

## 5.封装优点

在java中通过4种“访问控制符”分别为private、default、protected、public，实现封装。它们说明了面向对象的封装性，所以我们要利用它们尽可能的让访问权限降到最低，从而提高安全性。

1. private 表示私有，只有自己类能访问

2. default表示没有修饰符修饰，只有同一个包的类能访问

3. protected表示可以被同一个包的类以及其他包中的子类访问

4. public表示可以被该项目的所有包中的所有类访问

封装的优点：

1. 提高代码的安全性。

2. 提高代码的复用性。

3. “高内聚”：封装细节，便于修改内部代码，提高可维护性。

4. “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作

## 6.DNS服务干啥的？

Domain Name System ,在应用层访问域名时，解析域名。

## 7.TCP/IP的层次结构

+ 应用层
+ 传输层
+ 网络层
+ 链路层

## 8.git重置暂存区与工作区，与上一次commit保持一致，怎么做？

git reset --hard

- 当执行 **git reset HEAD** 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。

## 9.讲讲引用计数算法

### 1 判断对象存活一般有两种算法

+ 引用计数算法
+ 可达性分析算法

引用技数算法（Reference Counting）比较简单，对每个对象保存一整型的引用计数器属性。用于记录对象被引用的情况。

对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。

## 2 优点

+ 实现简单，垃圾对象便于辨识
+ 判定效率高，回收没有延迟性

### 3 缺点

+ 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。
+ 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。
+ 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有这类算法。

## 10.什么是反射？

### 类加载以及实例化的过程

要理解反射是什么必须首先理解java虚拟机是怎么加载一个类的。
以Student类为例：
①首先编译得到字节码文件（也就是二进制文件），存放在本地的内存中；
②当读到一个new Student()的指令之后（二进制指令），类加载器会到本地内存中寻找这个类的Class字节码文件并加载到jvm内存中；
③读入到jvm内存的同时会自动在方法去中产生一个Class对象（也就是Student类的模板）；
④根据得到的模板在堆中生成一个实例化对象。

### 反射的概念

如果你理解了类加载的过程，那么理解反射就很简单了：
反射就是在运行的时候（也就是已经jvm内存中已经存在了Class类的模板和实例化对象）根据是实例化对象得到Class模板的一个过程，通过得到这个类模板可以得到有关这个类的所有信息。如图所示

![image-20221228221826273](../image-20221228221826273.png)







