# 2023/2/20/21:00 时间 60分钟

## 1.事务的四大特性？ACID

+ 原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
+ 一致性：一致性是指事务执行结束后，**数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。**数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。
+ 隔离性：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，  必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。
+ 持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

## 2.事务的隔离级别？

1. **读未提交（Read Uncommitted）**：最低级别的隔离级别。在该隔离级别下，一个事务可以读取到其他事务尚未提交的数据，可能会出现脏读、不可重复读、幻读等问题。
2. **读已提交（Read Committed）**：一个事务只能读取到其他事务已经提交的数据。该级别解决了脏读的问题，但是可能出现不可重复读、幻读等问题。
3. **可重复读（Repeatable Read）**：在该隔离级别下，一个事务在执行期间多次读取同一数据，能够保证读取到的数据是一致的。该级别解决了不可重复读的问题，但是可能出现幻读的问题。
4. **序列化（Serializable）**：该级别是最高的隔离级别，能够完全解决脏读、不可重复读、幻读等问题。在该隔离级别下，事务串行执行，效率较低。

在实际应用中，需要根据数据的一致性要求和并发性能需求选择不同的隔离级别。

## 3.如何防止SQL注入？



## 4.脏读、不可重复读、幻读？怎么防止？

- 脏读：一个事务读取到了另一个事务尚未提交的数据，如果另一个事务回滚，那么前一个事务读取的数据就是无效的。
- 不可重复读：一个事务在执行过程中多次读取同一个数据，但是每次读取的结果都不同，可能是因为另一个事务在此期间修改了这个数据。
- 幻读：一个事务在执行过程中根据某个查询条件读取一批数据，然后另一个事务插入了符合这个查询条件的数据，此时第一个事务再次查询时，会发现有新插入的数据，就像发生了幻觉一样。

为了避免这些问题，可以采取以下措施：

1. 采用合适的事务隔离级别，例如将隔离级别设置为可重复读或序列化级别，可以有效避免脏读、不可重复读和幻读的问题。
2. 通过行级锁或表级锁来控制并发，例如在更新某个数据的时候加上排它锁，可以避免其他事务同时修改这个数据。
3. 合理设计数据表结构，避免使用过多的索引或者使用过长的事务，这些因素都可能导致并发问题的发生。
4. 对于需要频繁读取的数据，可以将其缓存到内存中，以减少数据库的访问，从而降低并发问题的发生。

## 5.数据库保存金额用什么数据类型？



## 6.mysql的存储引擎？



## 7.innodb和myisam的区别



## 8.讲一下B+树



## 9.讲一下强引用、弱引用、软引用



## 10.如何判断一个list是不是形成环

## 11.新生代、老年代

## 12.两个Hashset怎么找出他们的交集？

## 13.线程安全的集合有哪些？

## 14.vector和arrayList的区别？

## 15.线程的创建方式？

## 16.线程池的参数都有哪些？

[Java线程池七个参数详解：核心线程数、最大线程数、空闲线程存活时间、时间单位、工作队列、线程工厂、拒绝策略_线程池什么时候达到最大线程数_抓手的博客-CSDN博客](https://blog.csdn.net/Anenan/article/details/115603481)

1. **corePoolSize：核心线程数**

2. **maximumPoolSize：最大线程数**

3. **keepAliveTime：空闲线程存活时间**

4. **unit：时间单位**
5. **workQueue：工作队列**
6. **threadFactory：线程工厂**
7. **handler：拒绝策略**

## 17.三次握手？四次挥手？

## 18.手写一个快速排序？ 



